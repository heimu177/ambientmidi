<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage 11: Refined Core</title>
    <style>
        :root { --bg: #000; --accent: #00ff9d; --panel: rgba(5,5,8,0.8); }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: monospace; color: #fff; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 5; pointer-events: none;
            border-left: 3px solid var(--accent); padding-left: 15px;
        }
        .hud-title { font-size: 1.5rem; font-weight: bold; letter-spacing: 2px; }
        .hud-sub { font-size: 0.8rem; color: #888; margin-top: 5px;}

        #ui-layer {
            position: absolute; bottom: 40px; width: 100%; display: flex;
            justify-content: center; gap: 15px; z-index: 10;
        }
        .world-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #444; color: #aaa;
            padding: 15px 25px; border-radius: 12px; cursor: pointer;
            font-family: inherit; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px;
            backdrop-filter: blur(5px); transition: all 0.3s;
        }
        .world-btn:hover { border-color: #fff; color: #fff; transform: translateY(-2px); }
        .world-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,255,157,0.1); box-shadow: 0 0 20px rgba(0,255,157,0.2); }
        .stop-btn { border-color: #822; color: #f55; }

        #start-overlay {
            position: absolute; inset: 0; background: #000; z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
        }
        #init-btn {
            background: transparent; color: var(--accent);
            border: 2px solid var(--accent); padding: 20px 50px;
            font-size: 1.5rem; letter-spacing: 8px; font-weight: 900;
            cursor: pointer; transition: 0.3s; text-transform: uppercase;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        #init-btn:hover { background: var(--accent); color: #000; box-shadow: 0 0 60px var(--accent); }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="start-overlay">
        <button id="init-btn">IGNITE ENGINE</button>
        <p style="color:#444; margin-top:20px;">NEURAL SYNC READY</p>
    </div>

    <div id="hud">
        <div class="hud-title" id="world-title">VOID</div>
        <div class="hud-sub">SIMULATION: <span id="geo-status">NULL</span></div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <button class="world-btn" onclick="engine.switchWorld(0)">MIST</button>
        <button class="world-btn" onclick="engine.switchWorld(1)">ABYSS</button>
        <button class="world-btn" onclick="engine.switchWorld(2)">WOMB</button>
        <button class="world-btn" onclick="engine.switchWorld(3)">SPACE</button>
        <button class="world-btn stop-btn" onclick="engine.stop()">HALT</button>
    </div>

    <script type="x-shader/x-vertex" id="vertexShader">
        uniform float iTime;
        uniform float iBass;
        uniform int iScene;
        
        attribute float scale;
        varying vec3 vColor;
        varying float vAlpha;

        // Simplex Noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(
                     i.z + vec4(0.0, i1.z, i2.z, 1.0))
                   + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                   + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
        }

        void main() {
            vec3 pos = position;
            float t = iTime;
            vAlpha = 1.0;
            float sizeMult = 1.0;

            // SCENE 0: MIST (Matrix Bullet Time)
            if (iScene == 0) {
                t *= 0.1; // Super slow
                float n = snoise(vec3(pos.x*0.05, pos.y*0.05 + t, pos.z*0.05));
                pos.y += t * 5.0;
                pos.y = mod(pos.y + 50.0, 100.0) - 50.0;
                
                float dist = length(pos);
                float ripple = sin(dist * 0.2 - iTime * 2.0) * iBass * 5.0;
                pos += normalize(pos) * ripple;

                vColor = mix(vec3(0.6, 0.8, 1.0), vec3(1.0), n);
                sizeMult = 15.0;
            }

            // SCENE 1: ABYSS (Deep Fade)
            else if (iScene == 1) {
                pos.y += t * 2.0; 
                pos.y = mod(pos.y + 50.0, 100.0) - 50.0;
                pos.x += sin(t + pos.y * 0.1) * 2.0;
                
                float depth = (pos.y + 50.0) / 100.0;
                vAlpha = smoothstep(0.0, 0.3, depth) * smoothstep(1.0, 0.7, depth);
                
                vColor = vec3(0.0, 1.0, 0.6);
                sizeMult = 25.0;
            }

            // SCENE 2: WOMB (Neural Network - Brain Synapses)
            else if (iScene == 2) {
                // Create a fibrous web structure
                float noiseScale = 0.05;
                vec3 noisePos = pos * noiseScale;
                
                // Flow along connections
                float flow = snoise(noisePos + t * 0.2);
                
                // Snap particles to "veins"
                // If noise is close to 0, it's a vein
                float vein = 1.0 - abs(flow);
                vein = pow(vein, 8.0); // Sharpen contrast
                
                // Pulse travel
                float signal = sin(pos.x * 0.1 + pos.y * 0.1 + t * 3.0);
                signal = smoothstep(0.8, 1.0, signal); // Only bright spikes
                
                // Bass expand
                pos += normalize(pos) * iBass * 5.0;

                vAlpha = vein * 0.8 + signal; // Veins are dim, signals are bright
                vColor = mix(vec3(0.5, 0.0, 0.2), vec3(1.0, 0.8, 0.5), signal); // Dark red to Gold
                sizeMult = 20.0 + (signal * 30.0);
            }

            // SCENE 3: SPACE (Layered Deep Field)
            else {
                // Layering based on particle ID (using scale as random ID)
                float layer = floor(scale * 3.0); // 0, 1, or 2
                
                if (layer == 0.0) { // Dust (Fast, Foreground)
                    pos.z += t * 20.0;
                    pos.z = mod(pos.z, 100.0) - 50.0;
                    vColor = vec3(0.4, 0.6, 0.8);
                    sizeMult = 5.0;
                } else if (layer == 1.0) { // Stars (Slow, Mid)
                    pos.z += t * 5.0;
                    pos.z = mod(pos.z, 200.0) - 100.0;
                    vColor = vec3(1.0);
                    sizeMult = 15.0;
                } else { // Nebula (Static, Far)
                    float n = snoise(pos * 0.02);
                    vColor = mix(vec3(0.1, 0.0, 0.2), vec3(0.0, 0.1, 0.3), n);
                    vAlpha = 0.3;
                    sizeMult = 60.0;
                }
                
                // Rotation
                float rotSpeed = 0.05 * (layer + 1.0);
                float ang = t * rotSpeed;
                float x = pos.x * cos(ang) - pos.y * sin(ang);
                float y = pos.x * sin(ang) + pos.y * cos(ang);
                pos.x = x; pos.y = y;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            gl_PointSize = scale * sizeMult * (1.0 + iBass * 0.5) * (30.0 / -mvPosition.z);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r = length(uv);
            if (r > 0.5) discard;
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 2.0);
            gl_FragColor = vec4(vColor, glow * vAlpha);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const engine = {
            scene: null, camera: null, renderer: null, composer: null,
            particles: null, uniforms: null,
            analyser: null, dataArray: null, clock: new THREE.Clock(),

            init(analyser) {
                this.analyser = analyser;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 80);

                this.renderer = new THREE.WebGLRenderer({powerPreference:'high-performance', antialias:false});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.createParticles();

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                // REFINED BLOOM: Subtler
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.5, 0.3);
                this.composer.addPass(bloom);

                this.animate();
                window.addEventListener('resize', () => this.onResize());
                this.switchWorld(3); 
            },

            createParticles() {
                const count = 80000;
                const geo = new THREE.BufferGeometry();
                const pos = [];
                const scale = [];

                for(let i=0; i<count; i++) {
                    pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
                    scale.push(Math.random());
                }

                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geo.setAttribute('scale', new THREE.Float32BufferAttribute(scale, 1));

                this.uniforms = {
                    iTime: { value: 0 },
                    iBass: { value: 0 },
                    iScene: { value: 3 }
                };

                const mat = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.particles = new THREE.Points(geo, mat);
                this.scene.add(this.particles);
            },

            switchWorld(id) {
                this.uniforms.iScene.value = id;
                const names = ['MIST', 'ABYSS', 'WOMB', 'SPACE'];
                const desc = ['FROZEN RAIN', 'DEEP FADE', 'NEURAL WEB', 'DEEP FIELD'];
                
                document.getElementById('world-title').innerText = names[id];
                document.getElementById('geo-status').innerText = desc[id];
                
                document.querySelectorAll('.world-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.world-btn')[id].classList.add('active');
                
                audio.play(names[id].toLowerCase());
            },

            stop() {
                audio.stopAll();
                this.uniforms.iBass.value = 0.0;
                document.getElementById('geo-status').innerText = "HALTED";
                document.querySelectorAll('.world-btn').forEach(b => b.classList.remove('active'));
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                const t = this.clock.getElapsedTime();
                this.uniforms.iTime.value = t;

                if (this.analyser) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    let bass = 0; for(let i=0; i<10; i++) bass += this.dataArray[i];
                    this.uniforms.iBass.value = THREE.MathUtils.lerp(this.uniforms.iBass.value, bass/10/255, 0.2);
                }

                this.composer.render();
            },

            onResize() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        const audio = {
            ctx: null, master: null, activeNodes: [], analyser: null,
            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.7;
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 512;
                this.master.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                if (this.ctx.state === 'suspended') this.ctx.resume();
                return this.analyser;
            },
            stopAll() {
                this.activeNodes.forEach(n => { try{n.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+0.5); setTimeout(()=>n.stop(),600);}catch(e){} });
                this.activeNodes = [];
            },
            play(key) {
                this.stopAll();
                const bus = this.ctx.createGain();
                bus.gain.value=0; bus.gain.linearRampToValueAtTime(1, this.ctx.currentTime+1.5);
                bus.connect(this.master);
                const nodes = this.route(key, bus);
                this.activeNodes.push({stop:()=>nodes.forEach(n=>n.stop()), gain:bus.gain});
            },
            route(key, d) {
                if(key==='mist') return this.genMist(d);
                if(key==='abyss') return this.genAbyss(d);
                if(key==='womb') return this.genWomb(d);
                if(key==='space') return this.genPad(d);
                return [];
            },
            genMist(d){ const b=this.ctx.createBuffer(1,this.ctx.sampleRate*2,this.ctx.sampleRate); const da=b.getChannelData(0); for(let i=0;i<b.length;i++)da[i]=Math.random()*2-1; const s=this.ctx.createBufferSource();s.buffer=b;s.loop=true; const f=this.ctx.createBiquadFilter();f.type='highpass';f.frequency.value=1200; const g=this.ctx.createGain();g.gain.value=0.25; s.connect(f).connect(g).connect(d);s.start(); return[s]; },
            genAbyss(d){ const b=this.ctx.createBuffer(1,this.ctx.sampleRate*2,this.ctx.sampleRate); const da=b.getChannelData(0); let l=0; for(let i=0;i<b.length;i++){let w=Math.random()*2-1; da[i]=(l+(0.02*w))/1.02; l=da[i]; da[i]*=3.5;} const s=this.ctx.createBufferSource();s.buffer=b;s.loop=true; const f=this.ctx.createBiquadFilter();f.type='lowpass';f.frequency.value=180; const g=this.ctx.createGain();g.gain.value=0.5; s.connect(f).connect(g).connect(d);s.start(); return[s]; },
            genWomb(d){ const o=this.ctx.createOscillator();o.frequency.value=40; const g=this.ctx.createGain();g.gain.value=0; const l=this.ctx.createOscillator();l.frequency.value=1; const lg=this.ctx.createGain();lg.gain.value=0.4; l.connect(lg).connect(g.gain);o.connect(g).connect(d); o.start();l.start(); return[o,l]; },
            genPad(d){ const o=this.ctx.createOscillator();o.frequency.value=110; const g=this.ctx.createGain();g.gain.value=0.12; o.connect(g).connect(d);o.start(); return[o]; }
        };

        window.engine = engine;
        window.audio = audio;

        document.getElementById('init-btn').addEventListener('click', () => {
            document.getElementById('start-overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 800);
            const analyser = audio.init();
            engine.init(analyser);
        });
    </script>
</body>
</html>
