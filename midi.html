<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Obsidian Pan v41 | Three Independent Sequencers & Internal Booster Rack</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d12;
            --panel-bg: #1c1c24;
            --pan-body-dark: #202028;
            --pan-body-light: #32323c;
            --note-field-base: rgba(0, 0, 0, 0.4);
            --note-text-color: #dddddd;
            --accent-blue: #00bcd4; /* Cyan/Teal (Primary Accent - Synth) */
            --accent-magenta: #cf4f9a; /* Deep Purple/Magenta (Secondary Accent - Booster) */
            --accent-orange: #ff9800; /* Tertiary Accent (Sequencer B) */
            --accent-purple: #9c27b0; /* New Accent (Sequencer C) */
            --label-text: #999999;
            --shadow-light: rgba(255, 255, 255, 0.05);
            --shadow-dark: rgba(0, 0, 0, 0.8);
            
            /* TUTORIAL & SEQUENCER COLORS */
            --accent-yellow: #ffee58; /* Tutorial highlight / Active Step */ 
            --accent-green: #4caf50; /* Success feedback / Play Button */
            --accent-red: #ff5252; /* Error feedback / Record Button */

            --pan-size: 450px; 
            --control-width: 850px; /* Adjusted width for better spacing */
        }

        /* --- CRITICAL SCROLL FIXES FOR SAFARI --- */
        html { height: 100%; }
        body {
            background-color: var(--bg-color);
            margin: 0;
            min-height: 100vh; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            font-family: 'Poppins', sans-serif;
            overflow-y: auto; 
            overflow-x: hidden; 
            touch-action: pan-y; 
            user-select: none;
            color: var(--label-text);
        }
        /* -------------------------------------- */


        /* --- START OVERLAY (Unchanged) --- */
        #start-overlay {
            position: fixed; 
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; font-size: 1.1rem;
            transition: opacity 0.5s ease-out;
        }
        #start-overlay h2 { margin-bottom: 30px; font-weight: 300; letter-spacing: 4px; color: var(--accent-blue); }
        #start-btn {
            background: var(--accent-blue); color: var(--bg-color);
            border: none; padding: 15px 30px; border-radius: 8px;
            font-family: inherit; font-size: 1rem; cursor: pointer;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(0,188,212,0.4);
            transition: background 0.2s, box-shadow 0.2s;
        }

        /* --- MAIN CONTAINER --- */
        .pan-wrapper {
            display: flex; flex-direction: column; align-items: center;
            gap: 30px; 
            max-width: var(--control-width);
            width: 95%;
        }
        
        /* --- HANDPAN VISUAL (Unchanged) --- */
        .handpan-container {
            position: relative;
            width: var(--pan-size);
            height: var(--pan-size);
            background: radial-gradient(circle at 35% 35%, var(--pan-body-light), var(--pan-body-dark) 80%);
            border-radius: 50%;
            box-shadow: 
                -10px -10px 30px var(--shadow-light), 
                10px 10px 30px var(--shadow-dark), 
                inset 0 0 80px rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
        }

        .note-field {
            position: absolute;
            background-color: var(--note-field-base);
            border-radius: 50%;
            box-shadow: 
                inset 5px 5px 10px var(--shadow-dark), 
                inset -5px -5px 10px var(--shadow-light);
            cursor: pointer;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.2s, border 0.2s;
            display: flex; justify-content: center; align-items: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--note-text-color);
            z-index: 10; 
        }
        
        /* Note Hit Active Style */
        .note-field.active {
            transform: scale(0.92);
            box-shadow: 
                inset 2px 2px 5px var(--shadow-dark), 
                inset -2px -2px 5px var(--shadow-light),
                0 0 15px var(--accent-blue);
        }
        
        /* --- TUTORIAL MODE STYLES (Unchanged) --- */
        .note-field.tutorial-active {
            box-shadow: 0 0 25px var(--accent-yellow), 0 0 10px var(--accent-yellow) inset;
            transform: scale(1.05);
            background-color: rgba(255, 255, 0, 0.2); 
            border: 2px solid var(--accent-yellow);
        }

        .ding-note { width: 100px; height: 100px; }
        .outer-note { width: 70px; height: 70px; }


        /* --- CONTROL PANEL (Neumorphic Container) --- */
        .control-panel {
            background-color: var(--panel-bg);
            border-radius: 20px;
            padding: 20px 25px;
            box-shadow: 
                -8px -8px 15px var(--shadow-light), 
                8px 8px 15px var(--shadow-dark);
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        /* --- SLIDERS (Unchanged) --- */
        .slider-group {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .slider-container { 
            display: flex; 
            flex-direction: column;
            gap: 8px;
            align-items: center;
            flex-grow: 1;
        }
        .slider-container label {
            font-size: 0.8rem; 
            color: var(--note-text-color);
            font-weight: 300;
        }
        .slider-label-value {
             color: var(--accent-blue);
             font-size: 0.9rem;
        }
        
        .control-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #2a2a35; 
            border-radius: 3px;
            outline: none;
            box-shadow: inset 0 1px 3px var(--shadow-dark);
        }
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            box-shadow: 0 0 8px var(--accent-blue);
        }
        .control-slider.magenta::-webkit-slider-thumb {
            background: var(--accent-magenta);
            box-shadow: 0 0 8px var(--accent-magenta);
        }
        .control-slider.orange::-webkit-slider-thumb {
            background: var(--accent-orange);
            box-shadow: 0 0 8px var(--accent-orange);
        }
        
        h3 {
             color: var(--note-text-color); 
             font-weight: 600; 
             letter-spacing: 1px; 
             margin-bottom: 0;
        }
        .utility-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .utility-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: #2a2a35;
            color: var(--label-text);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light);
            cursor: pointer;
            transition: all 0.1s;
        }
        .utility-btn svg { width: 18px; height: 18px; fill: currentColor; }
        .utility-btn:active {
            box-shadow: inset 2px 2px 5px var(--shadow-dark), inset -2px -2px 5px var(--shadow-light);
            transform: scale(0.95);
        }
        .utility-btn.active {
            color: var(--accent-blue);
            box-shadow: 0 0 5px var(--accent-blue);
        }
        #booster-bypass.active {
            color: var(--accent-magenta);
            box-shadow: 0 0 5px var(--accent-magenta);
        }

        /* --- SEQUENCER GRID LAYOUT --- */
        .sequencer-container-grid {
             display: grid;
             grid-template-columns: repeat(3, 1fr); /* Three columns for A, B, C */
             gap: 20px;
             width: 100%;
             margin-top: 15px;
        }
        
        .sequencer-panel {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            background: #2a2a35;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }
        .seq-title {
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }
        /* Sequencer A (Default Blue) */
        .seq-a .seq-title { color: var(--accent-blue); }
        .seq-a .seq-step.note-recorded { background: var(--accent-blue); }
        /* Sequencer B (Orange) */
        .seq-b .seq-title { color: var(--accent-orange); }
        .seq-b .seq-step.note-recorded { background: var(--accent-orange); }
        /* Sequencer C (Purple) */
        .seq-c .seq-title { color: var(--accent-purple); }
        .seq-c .seq-step.note-recorded { background: var(--accent-purple); }


        .seq-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .seq-transport {
            display: flex;
            gap: 5px;
        }

        .seq-btn {
            width: 35px; height: 30px;
            border-radius: 6px;
            background: var(--panel-bg);
            color: var(--label-text);
            border: none;
            cursor: pointer;
            box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light);
            transition: all 0.1s;
        }
        .seq-btn.active {
            background-color: var(--accent-red);
            color: var(--note-text-color);
            box-shadow: inset 2px 2px 5px var(--shadow-dark), inset -2px -2px 5px var(--shadow-light);
        }
        .seq-btn#seq-play-btn.active {
            background-color: var(--accent-green);
        }

        .seq-btn:active {
            box-shadow: inset 2px 2px 5px var(--shadow-dark), inset -2px -2px 5px var(--shadow-light);
            transform: scale(0.98);
        }
        .seq-btn svg { width: 16px; height: 16px; fill: currentColor; }

        /* Sequencer Grid */
        .seq-grid {
            display: flex;
            gap: 3px;
            justify-content: space-between;
            width: 100%;
        }
        .seq-step {
            flex-grow: 1;
            flex-basis: 0;
            height: 12px;
            border-radius: 2px;
            background: #333340;
            transition: background 0.1s, border 0.1s;
            cursor: pointer;
            position: relative;
            border: 1px solid transparent;
        }

        .seq-step.active-step {
            /* Currently playing step OR Manually selected step */
            border: 1px solid var(--accent-yellow);
        }
        
        .seq-step.note-recorded.active-step {
             /* Playing a step with recorded data OR Selected recorded step */
             background: var(--accent-green) !important; /* Override specific color with GREEN for PLAYING */
             border: 1px solid var(--accent-yellow);
        }
        
        .seq-global-controls {
            display: flex; 
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }
        
        .seq-tempo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
        }
        #bpm-input {
            width: 60px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: #2a2a35;
            color: var(--note-text-color);
            text-align: center;
            font-family: inherit;
            box-shadow: inset 0 1px 3px var(--shadow-dark);
        }

        /* --- BOOSTER RACK STYLES (Unchanged) --- */
        .booster-rack {
             padding: 10px 0;
             border-top: 1px solid rgba(255, 255, 255, 0.05);
             margin-top: 20px;
        }
        #booster-status {
            text-align: center;
            padding: 10px;
            margin-top: 5px;
            background: #2a2a35;
            color: var(--note-text-color);
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            min-height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            border-left: 5px solid var(--accent-magenta);
            transition: all 0.2s;
        }
        .booster-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-top: 10px;
        }

        /* Scale Button Style */
        .scale-btn {
            background: #2a2a35;
            color: var(--label-text);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-grow: 1;
        }
        .scale-btn:hover {
            border-color: var(--accent-blue);
        }
        .scale-btn.active {
            background: var(--accent-blue);
            color: var(--bg-color);
            font-weight: 600;
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.5);
        }
        .scale-buttons-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding-top: 10px;
        }
        
        /* TUTORIAL LIST Buttons */
        .tutorial-list-btn {
             background: #333340;
             color: var(--note-text-color);
             flex-grow: 1;
             min-width: 45%;
        }
        .tutorial-list-btn:hover {
             border-color: var(--accent-yellow);
        }
        .tutorial-list-btn.active {
            background: var(--accent-yellow);
            color: var(--bg-color);
            box-shadow: 0 0 10px rgba(255, 238, 88, 0.5);
        }


        /* --- RESPONSIVENESS (iPad and smaller devices) --- */
        @media (max-width: 768px) {
            :root {
                --pan-size: 380px; 
                --control-width: 100%;
            }
            .slider-group {
                flex-direction: column;
                gap: 15px;
            }
            
            .sequencer-container-grid {
                grid-template-columns: 1fr; /* Single column on small screens */
            }
            .sequencer-panel {
                padding: 8px;
            }
            .seq-title {
                font-size: 0.9rem;
            }
            .seq-btn {
                 width: 30px; height: 25px;
            }
            .seq-tempo {
                 font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h2>OBSIDIAN PAN v41</h2>
        <p style="font-weight: 300;">Three Sequencers & Synth Booster Rack</p>
        <button id="start-btn">BEGIN SOUNDSCAPE</button>
    </div>

    <div class="pan-wrapper">
        
        <div class="control-panel">
            
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div class="utility-buttons">
                    <div class="utility-btn power" id="power-btn" title="Power On/Off">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M13 3C13 2.44772 12.5523 2 12 2C11.4477 2 11 2.44772 11 3V11C11 11.5523 11.4477 12 12 12C12.5523 12 13 11.5523 13 11V3Z"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20Z"/>
                        </svg>
                    </div>
                     <div class="utility-btn surface" id="surface-btn" title="Toggle Surface Hit Sound">
                         <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="5" fill="currentColor"/>
                         </svg>
                    </div>
                    <div class="utility-btn bluetooth" id="bluetooth-btn" title="Bluetooth/MIDI Input">
                         <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M7 17L17 7L12 2V22L17 17L7 7L12 12L7 17Z"/>
                        </svg>
                    </div>
                </div>
                <h3>MASTER MIXER</h3>
            </div>

            <div class="slider-group">
                <div class="slider-container">
                    <label for="volume-slider">MASTER VOLUME</label>
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="control-slider" id="volume-slider">
                    <span class="slider-label-value" id="volume-val">0.50</span>
                </div>
                <div class="slider-container">
                    <label for="reverb-slider">REVERB (SIZE)</label>
                    <input type="range" min="0" max="1" step="0.01" value="0.3" class="control-slider magenta" id="reverb-slider">
                    <span class="slider-label-value" id="reverb-val">0.30</span>
                </div>
                <div class="slider-container">
                    <label for="width-slider">DIMENSION (DELAY)</label> 
                    <input type="range" min="0" max="1" step="0.01" value="0.0" class="control-slider orange" id="width-slider">
                    <span class="slider-label-value" id="width-val">0.00</span>
                </div>
            </div>
            
            <h3 style="text-align: center; margin-top: 10px;">SEQUENCER RACK (16 STEPS)</h3>
            <div style="border-bottom: 1px solid rgba(255, 255, 255, 0.05);">
                <div class="seq-global-controls">
                    <div class="seq-transport">
                        <button class="seq-btn" id="seq-play-btn" title="Play All Sequences">
                            <svg viewBox="0 0 24 24"><path d="M8 5V19L19 12L8 5Z"/></svg>
                        </button>
                        <button class="seq-btn" id="seq-rec-btn" title="Toggle Global Recording">
                            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>
                        </button>
                        <button class="seq-btn" id="seq-clear-all-btn" title="Clear All Steps on A, B, and C">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="seq-tempo">
                        <label for="bpm-input">TEMPO (BPM)</label>
                        <input type="number" id="bpm-input" min="60" max="240" value="120">
                    </div>
                </div>
            </div>
            
            <div class="sequencer-container-grid">
                
                <div class="sequencer-panel seq-a">
                    <div class="seq-title">SEQUENCER A (Melody)</div>
                    <div class="seq-grid" id="seq-grid-A"></div>
                </div>
                
                <div class="sequencer-panel seq-b">
                    <div class="seq-title">SEQUENCER B (Harmony)</div>
                    <div class="seq-grid" id="seq-grid-B"></div>
                </div>
                
                <div class="sequencer-panel seq-c">
                    <div class="seq-title">SEQUENCER C (Rhythm)</div>
                    <div class="seq-grid" id="seq-grid-C"></div>
                </div>
                
            </div>
            <h3 style="text-align: center; margin-top: 10px; color: var(--accent-magenta);">BOOSTER RACK (SYNTH CHAIN INPUT)</h3>
            <div class="booster-rack">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <button class="scale-btn" id="booster-toggle-btn" style="flex-grow: 1; margin-right: 10px;">
                        ENABLE BOOSTER EFFECTS
                    </button>
                    <div class="utility-btn surface" id="booster-bypass" title="Bypass Filter/Flanger">
                         <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 1L3 5V11C3 16.55 6.84 21.78 12 23C17.16 21.78 21 16.55 21 11V5L12 1ZM12 14.5C10.62 14.5 9.5 13.38 9.5 12C9.5 10.62 10.62 9.5 12 9.5C13.38 9.5 14.5 10.62 14.5 12C14.5 13.38 13.38 14.5 12 14.5Z"/>
                        </svg>
                    </div>
                </div>
                <div id="booster-status" style="margin-top: 10px; border-left-color: var(--label-text);">
                    Booster is bypassed (Synth output goes directly to Master).
                </div>

                <div class="booster-controls" style="display: none;" id="booster-controls-panel">
                     <label for="filterFreq" style="color: var(--accent-magenta);">POLIVOKS FILTER Cutoff: <span id="freqValue" class="slider-label-value">200</span> Hz</label>
                    <input type="range" id="filterFreq" min="50" max="2000" value="200" step="10" class="control-slider magenta">

                    <label for="filterQ" style="color: var(--accent-magenta);">RESONANCE (Q): <span id="qValue" class="slider-label-value">10</span></label>
                    <input type="range" id="filterQ" min="0.1" max="30" value="10" step="0.1" class="control-slider magenta">
                    
                    <label for="envSensitivity" style="color: var(--accent-magenta);">ENVELOPE SWEEP Sensitivity: <span id="envValue" class="slider-label-value">1500</span> Hz Range</label>
                    <input type="range" id="envSensitivity" min="0" max="4000" value="1500" step="10" class="control-slider magenta">
                    
                    <label for="flangerDepth" style="color: var(--accent-magenta);">FLANGER/CHORUS Depth: <span id="depthValue" class="slider-label-value">0.0030</span> sec</label>
                    <input type="range" id="flangerDepth" min="0.001" max="0.01" value="0.003" step="0.0001" class="control-slider magenta">

                    <label for="flangerRate" style="color: var(--accent-magenta);">FLANGER Speed (LFO Rate): <span id="rateValue" class="slider-label-value">0.5</span> Hz</label>
                    <input type="range" id="flangerRate" min="0.1" max="5" value="0.5" step="0.1" class="control-slider magenta">
                </div>
            </div>
            <h3 style="text-align: center; margin-top: 10px;">TUTORIAL MODE</h3>
            <div style="border-top: 1px solid rgba(255, 255, 255, 0.05); padding-top: 10px;">
                <button class="scale-btn" id="tutorial-btn" style="flex-grow: 1;">
                    START TUTORIAL MODE
                </button>
                <div id="tutorial-list" style="display: none; justify-content: space-around; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                    </div>
                <div id="tutorial-display" style="display: none; text-align: center; padding: 10px; margin-top: 10px; background: #2a2a35; color: var(--note-text-color); border-radius: 10px; font-size: 1rem; font-weight: 500; min-height: 38px; align-items: center; justify-content: center; box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); border-left: 5px solid var(--accent-yellow); transition: all 0.2s;">
                    Select a lesson above to begin...
                </div>
            </div>
            <h3 style="text-align: center; margin-top: 10px;">SCALE SELECTION</h3>
            <div class="scale-buttons-group" id="scale-selector" style="border-top: 1px solid rgba(255, 255, 255, 0.05);">
                <button class="scale-btn active" data-scale-index="0">D Minor (Amara)</button>
                <button class="scale-btn" data-scale-index="1">C Major (Ionian)</button>
                <button class="scale-btn" data-scale-index="2">F Lydian (Dream)</button>
                <button class="scale-btn" data-scale-index="3">E Minor Pent.</button>
                <button class="scale-btn" data-scale-index="4">A Harmonic Minor</button>
                <button class="scale-btn" data-scale-index="5">D4 Solfeggio</button>
                <button class="scale-btn" data-scale-index="6">C4 Chakra Scale</button>
            </div>
        </div>
        
        <div class="handpan-container" id="handpan-visual">
        </div>
    </div>

    <script>
        // --- AUDIO CORE SETUP ---
        let audioCtx;
        let isAudioInitialized = false;
        let masterGain, masterCompressor, masterLimiter;
        let dryGain; 
        let boosterInputMixer; 
        
        // REVERB & AMBIENCE NODES
        let globalReverb, globalReverbSend; 
        
        // DIMENSION/SUPERMASSIVE EFFECT NODES
        let dimensionDelay, dimensionLFO, dimensionFeedback, dimensionHPF, dimensionLimiter; 

        // --- BOOSTER RACK NODES ---
        let boosterSourceNode; 
        let boosterFilterNode, boosterAnalyserNode;
        let boosterFlangerDelay, boosterFlangerLFO, boosterFlangerFeedback, boosterLFOAmplitude;
        let boosterOutputGain; 
        
        let boosterEnabled = false; 
        let boosterBypassed = true; 
        const FILTER_BASE_FREQ = 100;

        // --- CONSTANTS ---
        const MAX_DIMENSION_DELAY = 0.25; 
        const LFO_RATE = 0.2; 
        const MAX_FEEDBACK_GAIN = 0.60; 
        const MAX_FLANGER_DELAY = 0.02;

        // --- DEFAULT PARAMETERS ---
        const DEFAULT_PARAMS = {
            volume: 0.5,
            reverb: 0.3, 
            dimension: 0.0, 
            scale: 0, 
            power: false,
            surfaceSound: true 
        };

        // --- SEQUENCER LOGIC STATE (UPDATED FOR A, B, C) ---
        const NUM_STEPS = 16;
        let sequencerDataA = Array(NUM_STEPS).fill(null); 
        let sequencerDataB = Array(NUM_STEPS).fill(null); 
        let sequencerDataC = Array(NUM_STEPS).fill(null); 
        
        let currentStep = -1; 
        // selectedStep now holds the step index for step input mode for each sequencer
        let selectedStep = { A: -1, B: -1, C: -1 }; 
        let isPlaying = false;
        let isRecording = false; // CHANGED: Default is OFF
        let stepIntervalTime = 500; 
        let seqTimer; 
        let animationFrameId; 

        // --- TUTORIAL LOGIC STATE (Unchanged) ---
        let isTutorialMode = false;
        let currentLesson = null;
        let currentStepIndex = 0;
        let stepDelayTimeout = null;
        let isWaitingForHit = false;

        // --- UI & PARAMETERS ---
        const startButton = document.getElementById('start-btn');
        const powerButton = document.getElementById('power-btn');
        const surfaceButton = document.getElementById('surface-btn');
        const handpanVisual = document.getElementById('handpan-visual');
        const tutorialButton = document.getElementById('tutorial-btn');
        const tutorialList = document.getElementById('tutorial-list');
        const tutorialDisplay = document.getElementById('tutorial-display');
        const boosterToggleButton = document.getElementById('booster-toggle-btn');
        const boosterStatus = document.getElementById('booster-status');
        const boosterPanel = document.getElementById('booster-controls-panel');
        const boosterBypassBtn = document.getElementById('booster-bypass');

        const sliders = {
            volume: document.getElementById('volume-slider'),
            reverb: document.getElementById('reverb-slider'),
            dimension: document.getElementById('width-slider') 
        };
        const sliderVals = {
             volume: document.getElementById('volume-val'),
             reverb: document.getElementById('reverb-val'),
             dimension: document.getElementById('width-val') 
        };
        
        // Sequencer UI Elements
        const seqGridElA = document.getElementById('seq-grid-A');
        const seqGridElB = document.getElementById('seq-grid-B');
        const seqGridElC = document.getElementById('seq-grid-C');
        const seqPlayBtn = document.getElementById('seq-play-btn');
        const seqRecBtn = document.getElementById('seq-rec-btn');
        const seqClearAllBtn = document.getElementById('seq-clear-all-btn');
        const bpmInput = document.getElementById('bpm-input');

        let currentParams = { ...DEFAULT_PARAMS }; 

        // --- LESSON DATA (Unchanged) ---
        const LESSONS = {
            "Simple Melody": {
                scaleIndex: 0,
                sequence: [0, 1, 2, 1, 4, 3, 0], 
                names: ["Ding", "A3", "C4", "A3", "E4", "D4", "Ding"]
            },
            "Twinkle Star": {
                scaleIndex: 0, 
                sequence: [1, 1, 5, 5, 6, 6, 5],
                names: ["A3", "A3", "F4", "F4", "G4", "G4", "F4"]
            },
            "Ambient Chord": {
                scaleIndex: 0, 
                sequence: [0, 2, 4, 7, 4, 2, 0],
                names: ["Ding", "C4", "E4", "A4", "E4", "C4", "Ding"]
            },
            "FF Prelude Arp.": {
                scaleIndex: 0,
                sequence: [3, 1, 2, 3, 4, 2, 1, 0, 3],
                names: ["D4", "A3", "C4", "D4", "E4", "C4", "A3", "D3", "D4"]
            },
            "Chrono Trigger Theme": {
                scaleIndex: 0,
                sequence: [1, 2, 3, 4, 3, 2, 1, 2, 0],
                names: ["A3", "C4", "D4", "E4", "D4", "C4", "A3", "C4", "D3"]
            }
        };


        // --- SCALE DEFINITIONS (9 NOTES) ---
        const NOTE_FREQUENCIES = {
            // D3, A3, C4, D4, E4, F4, G4, A4, B4
            0: [146.83, 220.00, 261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88], 
            // C3, G3, A3, C4, D4, E4, F4, G4, A4
            1: [130.81, 196.00, 220.00, 261.63, 293.66, 329.63, 349.23, 392.00, 440.00], 
            // F3, C4, D4, E4, F4, G4, A4, B4, C5
            2: [174.61, 261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25], 
            // E3, A3, B3, D4, E4, G4, A4, B4, C#5
            3: [164.81, 220.00, 246.94, 293.66, 329.63, 392.00, 440.00, 493.88, 554.37], 
            // A3, C4, D4, E4, F4, G#4, A4, B4, C5
            4: [220.00, 261.63, 293.66, 329.63, 349.23, 415.30, 440.00, 493.88, 523.25], 
            // D4, F4, G4, Re, A4, Mi, Fa, Sol, La
            5: [293.66, 349.23, 392.00, 417.00, 440.00, 528.00, 639.00, 741.00, 852.00], 
            // Ut, Re, A4, Mi, Fa, Sol, La, Si, High
            6: [396.00, 417.00, 440.00, 528.00, 639.00, 741.00, 852.00, 963.00, 1074.0]  
        };
        
        const NOTE_NAMES_D_MINOR = ["D3", "A3", "C4", "D4", "E4", "F4", "G4", "A4", "B4"];
        const NOTE_NAMES_CHAKRA = ["Root", "Sacral", "Solar", "Heart", "Throat", "3rd Eye", "Crown", "High1", "High2"];

        // --- SEQUENCER DEFINITIONS ---
        const SEQUENCER_MAPS = {
             A: {
                 data: sequencerDataA,
                 gridEl: seqGridElA,
                 colorClass: 'seq-a',
                 activeStep: -1 // Used for step input
             },
             B: {
                 data: sequencerDataB,
                 gridEl: seqGridElB,
                 colorClass: 'seq-b',
                 activeStep: -1 // Used for step input
             },
             C: {
                 data: sequencerDataC,
                 gridEl: seqGridElC,
                 colorClass: 'seq-c',
                 activeStep: -1 // Used for step input
             }
        };
        
        // --- INITIALIZATION ---
        startButton.addEventListener('click', async () => {
            if (isAudioInitialized) return;
            
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                await audioCtx.resume();
                
                // 1. Initialize Audio and Controls
                initAudioGraph();
                initSliderInteractions();
                initScaleButtonInteractions();
                initUtilityButtonInteractions();
                
                // 2. Sequencer Init
                initSequencer();

                // 3. CREATE the Handpan Notes (9 notes now)
                generateHandpanNotes(NOTE_FREQUENCIES[DEFAULT_PARAMS.scale], NOTE_NAMES_D_MINOR); 
                
                // 4. Initialize SURFACE HIT HANDLER
                initSurfaceHitHandler();

                // 5. Initialize TUTORIAL
                initTutorialInteractions(); 
                
                // 6. Initialize Booster Rack Controls
                initBoosterControls();
                
                isAudioInitialized = true; 
                resetUIAndParams(); 
                connectBoosterGraph(); 

                document.getElementById('start-overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
            } catch (e) {
                alert("Audio failed to start. Error: " + e.message);
                console.error("Audio Init Error:", e);
            }
        });
        
        function createHardClipCurve(amount = 0.8) {
            const n = 2048;
            const curve = new Float32Array(n);
            const half = n / 2;
            for (let i = 0; i < n; i++) {
                let x = (i - half) / half;
                if (x > amount) {
                    curve[i] = amount;
                } else if (x < -amount) {
                    curve[i] = -amount;
                } else {
                    curve[i] = x;
                }
            }
            return curve;
        }

        // --- AUDIO GRAPH SETUP (Unchanged from v40) ---
        function initAudioGraph() {
            masterGain = audioCtx.createGain();
            masterGain.gain.value = currentParams.volume;
            masterCompressor = audioCtx.createDynamicsCompressor();
            masterLimiter = audioCtx.createDynamicsCompressor();
            masterLimiter.threshold.value = -3; 
            masterLimiter.ratio.value = 20; 
            
            masterGain.connect(masterCompressor).connect(masterLimiter).connect(audioCtx.destination);
            
            // --- 1. SYNTH/SEQUENCER PATH NODES ---
            dryGain = audioCtx.createGain(); 
            
            boosterInputMixer = audioCtx.createGain(); 
            boosterSourceNode = boosterInputMixer; 

            // Reverb Path
            globalReverb = audioCtx.createConvolver();
            globalReverb.buffer = createReverbImpulse(5.0);
            globalReverbSend = audioCtx.createGain();
            globalReverbSend.gain.setValueAtTime(currentParams.reverb, audioCtx.currentTime);
            globalReverbSend.connect(globalReverb).connect(boosterInputMixer); 
            
            // Dimension/Delay Path
            dimensionDelay = audioCtx.createDelay(MAX_DIMENSION_DELAY);
            dimensionFeedback = audioCtx.createGain(); 
            dimensionHPF = audioCtx.createBiquadFilter(); 
            dimensionHPF.type = 'highpass';
            dimensionHPF.frequency.value = 100; 
            dimensionLimiter = audioCtx.createWaveShaper(); 
            dimensionLimiter.curve = createHardClipCurve(0.8); 
            dimensionLFO = audioCtx.createOscillator(); 
            dimensionLFO.type = 'sine';
            dimensionLFO.frequency.value = LFO_RATE; 
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 0.0; 
            dimensionLFO.connect(lfoGain);
            dimensionLFO.start(0);
            dimensionLFO.gain = lfoGain.gain;
            
            dryGain.connect(dimensionDelay);
            dimensionDelay.connect(dimensionFeedback); 
            dimensionFeedback.connect(dimensionLimiter); 
            dimensionLimiter.connect(dimensionHPF).connect(boosterInputMixer); 
            dimensionHPF.connect(dimensionDelay); 
            lfoGain.connect(dimensionDelay.delayTime); 
            
            dimensionFeedback.gain.setValueAtTime(0.0, audioCtx.currentTime);
            
            dryGain.connect(boosterInputMixer); 

            // --- 2. BOOSTER RACK NODES ---
            boosterFilterNode = audioCtx.createBiquadFilter();
            boosterAnalyserNode = audioCtx.createAnalyser();
            boosterFlangerDelay = audioCtx.createDelay(MAX_FLANGER_DELAY); 
            boosterFlangerFeedback = audioCtx.createGain();
            boosterFlangerLFO = audioCtx.createOscillator();
            boosterLFOAmplitude = audioCtx.createGain();
            boosterOutputGain = audioCtx.createGain(); 

            // Setup Filter
            boosterFilterNode.type = 'lowpass';
            boosterFilterNode.frequency.setValueAtTime(FILTER_BASE_FREQ, audioCtx.currentTime);
            boosterFilterNode.Q.setValueAtTime(10, audioCtx.currentTime);

            // Setup Flanger LFO
            boosterFlangerLFO.type = 'sine';
            boosterFlangerLFO.frequency.setValueAtTime(0.5, audioCtx.currentTime);
            boosterLFOAmplitude.gain.setValueAtTime(0.003, audioCtx.currentTime); 
            boosterFlangerLFO.connect(boosterLFOAmplitude).connect(boosterFlangerDelay.delayTime);
            boosterFlangerFeedback.gain.setValueAtTime(0.8, audioCtx.currentTime); 
            boosterFlangerLFO.start(0);
            
            // Connect Flanger feedback loop
            boosterFlangerDelay.connect(boosterFlangerFeedback).connect(boosterFlangerDelay);
            
            boosterOutputGain.connect(masterGain);
            
            runEnvelopeFollowerLoop(); 
        }

        function createReverbImpulse(duration) {
            const rate = audioCtx.sampleRate;
            const len = rate * duration;
            const buff = audioCtx.createBuffer(2, len, rate);
            for (let i = 0; i < len; i++) {
                const d = Math.pow(1 - i / len, 2.0);
                buff.getChannelData(0)[i] = (Math.random() * 2 - 1) * d * 0.4;
                buff.getChannelData(1)[i] = (Math.random() * 2 - 1) * d * 0.4;
            }
            return buff;
        }

        function updateMasterGains() {
            if (!isAudioInitialized) return;
            const now = audioCtx.currentTime;
            
            masterGain.gain.setTargetAtTime(currentParams.volume, now, 0.05);
            globalReverbSend.gain.setTargetAtTime(currentParams.reverb, now, 0.05);
            
            const dimVal = currentParams.dimension;
            dimensionDelay.delayTime.setTargetAtTime(0.05 + (dimVal * 0.20), now, 0.01);
            dimensionLFO.gain.setTargetAtTime(dimVal * 0.015, now, 0.05); 
            dimensionFeedback.gain.setTargetAtTime(dimVal * MAX_FEEDBACK_GAIN, now, 0.05); 
            dimensionHPF.frequency.setTargetAtTime(100 + (dimVal * 400), now, 0.05);
        }
        
        // --- BOOSTER RACK LOGIC (Unchanged) ---
        function initBoosterControls() {
            boosterToggleButton.addEventListener('click', toggleBoosterEnabled);
            boosterBypassBtn.addEventListener('click', toggleBoosterBypass);

            document.getElementById('filterFreq').addEventListener('input', updateBoosterFilter);
            document.getElementById('filterQ').addEventListener('input', updateBoosterFilter);
            document.getElementById('envSensitivity').addEventListener('input', updateBoosterEnvDisplay);
            document.getElementById('flangerDepth').addEventListener('input', updateBoosterFlanger);
            document.getElementById('flangerRate').addEventListener('input', updateBoosterFlanger);

            updateBoosterFilter({target: document.getElementById('filterFreq')});
            updateBoosterFilter({target: document.getElementById('filterQ')});
            updateBoosterFlanger({target: document.getElementById('flangerDepth')});
            updateBoosterFlanger({target: document.getElementById('flangerRate')});
        }
        
        function toggleBoosterEnabled() {
            if (!isAudioInitialized) return;

            boosterEnabled = !boosterEnabled;
            
            boosterToggleButton.classList.toggle('active', boosterEnabled);
            boosterPanel.style.display = boosterEnabled ? 'flex' : 'none';
            
            if (boosterEnabled) {
                boosterBypassed = true; 
                boosterBypassBtn.classList.remove('active');
                boosterToggleButton.textContent = 'DISABLE BOOSTER EFFECTS';
            } else {
                boosterBypassed = true; 
                boosterToggleButton.textContent = 'ENABLE BOOSTER EFFECTS';
            }
            
            connectBoosterGraph();
        }

        function connectBoosterGraph() {
            boosterSourceNode.disconnect();
            boosterFilterNode.disconnect();
            boosterFlangerDelay.disconnect();
            boosterAnalyserNode.disconnect();

            boosterSourceNode.connect(boosterAnalyserNode);
            
            if (!boosterEnabled) {
                // PATH 1: BOOSTER DISABLED (Synth Mixer -> Master)
                boosterSourceNode.connect(boosterOutputGain);
                boosterStatus.textContent = 'Booster is disabled (Direct output).';
                boosterStatus.style.borderLeftColor = 'var(--label-text)';
                boosterBypassBtn.style.pointerEvents = 'none';

            } else if (boosterBypassed) {
                // PATH 2: BOOSTER ENABLED, BYPASSED (Synth Mixer -> Booster Output Gain -> Master)
                boosterSourceNode.connect(boosterOutputGain);
                boosterStatus.textContent = 'Booster is enabled, effects BYPASSED.';
                boosterStatus.style.borderLeftColor = 'var(--accent-magenta)';
                boosterBypassBtn.style.pointerEvents = 'auto';

            } else {
                // PATH 3: BOOSTER ACTIVE (Synth Mixer -> Filter/Flanger -> Booster Output Gain -> Master)
                boosterSourceNode.connect(boosterFilterNode);
                boosterFilterNode.connect(boosterOutputGain);
                
                boosterFilterNode.connect(boosterFlangerDelay);
                boosterFlangerDelay.connect(boosterOutputGain);
                
                boosterStatus.textContent = 'Booster is active. Filter/Flanger processing synth sound.';
                boosterStatus.style.borderLeftColor = 'var(--accent-green)';
                boosterBypassBtn.style.pointerEvents = 'auto';
            }
        }

        function toggleBoosterBypass() {
            if (!boosterEnabled) return;
            
            boosterBypassed = !boosterBypassed;
            boosterBypassBtn.classList.toggle('active', !boosterBypassed); 
            
            connectBoosterGraph();
        }

        function updateBoosterFilter(e) {
            const now = audioCtx.currentTime;
            if (e.target.id === 'filterFreq') {
                const freq = parseFloat(e.target.value);
                boosterFilterNode.frequency.setTargetAtTime(freq, now, 0.05);
                document.getElementById('freqValue').textContent = freq;
            } else if (e.target.id === 'filterQ') {
                const q = parseFloat(e.target.value);
                boosterFilterNode.Q.setTargetAtTime(q, now, 0.05);
                document.getElementById('qValue').textContent = q;
            }
        }
        
        function updateBoosterEnvDisplay(e) {
             document.getElementById('envValue').textContent = e.target.value;
        }

        function updateBoosterFlanger(e) {
            const now = audioCtx.currentTime;
            if (e.target.id === 'flangerDepth') {
                const depth = parseFloat(e.target.value);
                boosterLFOAmplitude.gain.setTargetAtTime(depth, now, 0.05); 
                document.getElementById('depthValue').textContent = depth.toFixed(4);
            } else if (e.target.id === 'flangerRate') {
                const rate = parseFloat(e.target.value);
                boosterFlangerLFO.frequency.setTargetAtTime(rate, now, 0.05);
                document.getElementById('rateValue').textContent = rate;
            }
        }

        function runEnvelopeFollowerLoop() {
            const bufferLength = boosterAnalyserNode.fftSize; 
            const dataArray = new Uint8Array(bufferLength);
            boosterAnalyserNode.getByteTimeDomainData(dataArray);

            let sumOfSquares = 0;
            for (let i = 0; i < bufferLength; i++) {
                const value = (dataArray[i] / 128.0) - 1;
                sumOfSquares += value * value;
            }
            const rms = Math.sqrt(sumOfSquares / bufferLength);

            const sensitivity = parseFloat(document.getElementById('envSensitivity').value) || 0;
            const sweepAmount = rms * rms * rms * sensitivity; 
            
            const baseFreq = parseFloat(document.getElementById('filterFreq').value);
            const newCutoff = Math.min(baseFreq + sweepAmount, audioCtx.sampleRate / 2);

            const now = audioCtx.currentTime;
            boosterFilterNode.frequency.setTargetAtTime(newCutoff, now, 0.05); 

            animationFrameId = requestAnimationFrame(runEnvelopeFollowerLoop);
        }

        // --- SYNTHESIS ENGINE (NOTES) (Unchanged) ---
        function triggerNote(freq, velocity, isEdgeHit) {
            if (!isAudioInitialized || !currentParams.power) return;
            const now = audioCtx.currentTime;

            const initialGain = 0.05 + (velocity * 0.65); 
            const envelopeTime = 8.0 + (velocity * 2.0); 

            const masterVoiceGain = audioCtx.createGain();
            masterVoiceGain.gain.setValueAtTime(0, now);
            masterVoiceGain.gain.linearRampToValueAtTime(initialGain, now + 0.005);
            masterVoiceGain.gain.exponentialRampToValueAtTime(0.0001, now + envelopeTime); 
            
            const reverbVoiceSend = audioCtx.createGain();
            reverbVoiceSend.gain.value = currentParams.reverb * velocity; 

            const lpf = audioCtx.createBiquadFilter();
            lpf.type = 'lowpass';
            const cutoffFreq = 2000 + (velocity * 10000); 
            lpf.frequency.setValueAtTime(cutoffFreq, now);
            lpf.Q.setValueAtTime(0.7, now); 

            masterVoiceGain.connect(dryGain);
            masterVoiceGain.connect(reverbVoiceSend).connect(globalReverbSend);
            
            lpf.connect(masterVoiceGain);

            createPartial(freq, 1.0, 0.005, 5.0, lpf, 'sine');
            createPartial(freq * 2.0, 0.5, 0.01, 3.5, lpf, 'sine');
            createPartial(freq * 3.007, 0.35, 0.015, 2.5, lpf, 'sine');
            createPartial(freq * 4.25, 0.1, 0.005, 0.5, lpf, 'triangle');
            
            if (isEdgeHit && currentParams.surfaceSound) {
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(0, now);
                noiseGain.gain.linearRampToValueAtTime(0.3 * velocity, now + 0.001); 
                noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5); 
                
                const noise = createNoiseBuffer(0.5); 
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(4000, now); 

                noise.connect(filter).connect(noiseGain).connect(dryGain);
                noise.start(now);
                noise.stop(now + 0.5);
            }

            setTimeout(() => {
                try { 
                    masterVoiceGain.disconnect();
                    reverbVoiceSend.disconnect();
                    lpf.disconnect(); 
                } catch(e){}
            }, envelopeTime * 1000 + 500);
        }

        function triggerSurfaceSound(velocity) {
             if (!isAudioInitialized || !currentParams.power || !currentParams.surfaceSound) return; 
             const now = audioCtx.currentTime;
             
             const resonanceFreq = 80; 
             const initialGain = 0.05 + (velocity * 0.1); 
             const decayTime = 1.0 + (velocity * 0.5); 
             
             const bodyGain = audioCtx.createGain();
             bodyGain.gain.setValueAtTime(0, now);
             bodyGain.gain.linearRampToValueAtTime(initialGain, now + 0.01);
             bodyGain.gain.exponentialRampToValueAtTime(0.0001, now + decayTime);
             
             bodyGain.connect(dryGain);

             const osc = audioCtx.createOscillator();
             osc.type = 'sine';
             osc.frequency.setValueAtTime(resonanceFreq, now);

             const filter = audioCtx.createBiquadFilter();
             filter.type = 'bandpass';
             filter.frequency.setValueAtTime(resonanceFreq * 1.5, now);
             filter.Q.setValueAtTime(5, now);
             
             osc.connect(filter).connect(bodyGain);
             osc.start(now);
             osc.stop(now + decayTime + 0.1);
             
             const noiseGain = audioCtx.createGain();
             noiseGain.gain.setValueAtTime(0, now);
             noiseGain.gain.linearRampToValueAtTime(0.1 * velocity, now + 0.001);
             noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2); 
             
             const noise = createNoiseBuffer(0.2);
             noise.connect(noiseGain).connect(dryGain);
             noise.start(now);
             noise.stop(now + 0.2);

             setTimeout(() => {
                 try {
                     bodyGain.disconnect();
                     osc.disconnect();
                     noiseGain.disconnect();
                     noise.disconnect();
                 } catch(e){}
             }, decayTime * 1000 + 500);
        }

        function createPartial(baseFreq, amp, attack, decay, destinationNode, type = 'sine') {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = type;
            osc.frequency.value = baseFreq;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(amp, now + attack);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + decay);

            osc.connect(gain);
            gain.connect(destinationNode); 
            osc.start(now);
            osc.stop(now + decay + 0.1);
        }
        
        function createNoiseBuffer(duration) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            return source;
        }

        // --- HANDPAN UI LOGIC (UPDATED for 9 notes) ---
        function generateHandpanNotes(freqArray, namesArray) {
            handpanVisual.innerHTML = '';
            
            // Note: The total number of notes is now 9 (0 to 8)
            const outerNotesData = freqArray.slice(1);
            
            const style = getComputedStyle(handpanVisual);
            const containerWidthStr = style.getPropertyValue('--pan-size') || '450px';
            const containerWidth = parseFloat(containerWidthStr);
            
            const center = containerWidth / 2;
            const radius = center * 0.75; 

            // Ding Note (Index 0)
            const dingEl = document.createElement('div');
            dingEl.className = 'note-field ding-note';
            dingEl.dataset.freq = freqArray[0];
            dingEl.dataset.noteIndex = 0;
            dingEl.textContent = namesArray[0]; 
            handpanVisual.appendChild(dingEl);
            const dingSize = 100;
            dingEl.style.left = `${center - dingSize / 2}px`;
            dingEl.style.top = `${center - dingSize / 2}px`;

            // Outer Notes (Index 1 to 8)
            outerNotesData.forEach((freq, index) => {
                const totalOuterNotes = outerNotesData.length; // 8 notes
                const angle = (index / totalOuterNotes) * 2 * Math.PI - (Math.PI / 2);
                const x = center + radius * Math.cos(angle);
                const y = center + radius * Math.sin(angle);
                
                const el = document.createElement('div');
                el.className = 'note-field outer-note';
                el.dataset.freq = freq;
                el.dataset.noteIndex = index + 1; // Index 1 through 8
                el.textContent = namesArray[index + 1];
                handpanVisual.appendChild(el);
                
                const outerSize = 70;
                el.style.left = `${x - outerSize / 2}px`; 
                el.style.top = `${y - outerSize / 2}px`;  
            });
            
            document.querySelectorAll('.note-field').forEach(el => {
                el.removeEventListener('mousedown', handleNoteInteractionStart);
                el.removeEventListener('touchstart', handleNoteInteractionStart);
                
                el.addEventListener('mousedown', handleNoteInteractionStart);
                el.addEventListener('touchstart', handleNoteInteractionStart);
                el.addEventListener('mouseup', handleNoteInteractionEnd);
                el.addEventListener('mouseleave', handleNoteInteractionEnd);
                el.addEventListener('touchend', handleNoteInteractionEnd);
                el.addEventListener('touchcancel', handleNoteInteractionEnd);
            });
        }
        
        function initSurfaceHitHandler() {
            handpanVisual.removeEventListener('mousedown', handleSurfaceInteraction);
            handpanVisual.removeEventListener('touchstart', handleSurfaceInteraction);

            handpanVisual.addEventListener('mousedown', handleSurfaceInteraction);
            handpanVisual.addEventListener('touchstart', handleSurfaceInteraction);
        }

        function handleSurfaceInteraction(e) {
            e.preventDefault();
            
            if (e.target.classList.contains('note-field') || e.target.closest('.note-field')) {
                return; 
            }
            
            if (!isAudioInitialized || !currentParams.power || !currentParams.surfaceSound) return;

            let velocity = getVelocityFromEvent(e);
            
            if (velocity < 0.5) velocity = 0.5;

            triggerSurfaceSound(velocity);
        }

        
        // --- NOTE INTERACTION HANDLER (UPDATED for Step Input Isolation) ---
        function handleNoteInteractionStart(e) {
            e.preventDefault();
            const el = this;

            if (!isAudioInitialized || !currentParams.power) return;
            
            let velocity = getVelocityFromEvent(e);
            let clientX, clientY;
            
            if (e.type.startsWith('touch') && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const hitData = getHitData(el, clientX, clientY);
            const freq = parseFloat(el.dataset.freq);
            const noteIndex = parseInt(el.dataset.noteIndex);

            if (isTutorialMode) {
                checkTutorialHit(el, velocity, hitData.isEdgeHit);
            } else {
                el.classList.add('active'); 
                triggerNote(freq, velocity, hitData.isEdgeHit);
                
                // SEQUENCER LOGIC (GLOBAL RECORDING / STEP INPUT)
                if (isRecording) {
                    let recorded = false;

                    // Check for Step Input Mode first (Priority 1: Step-by-Step Programming)
                    ['A', 'B', 'C'].forEach(seqId => {
                        const seqMap = SEQUENCER_MAPS[seqId];
                        
                        if (seqMap.activeStep !== -1) {
                            // A sequencer is in Step Input Mode. Only record to this one.
                            const stepToRecord = seqMap.activeStep;
                            recordNoteToStep(noteIndex, velocity, stepToRecord, seqMap.data, seqMap.gridEl);
                            recorded = true; 

                            // Advance step selection visually and logically
                            const currentStepEl = seqMap.gridEl.querySelector(`[data-step="${stepToRecord}"]`);
                            if (currentStepEl) currentStepEl.classList.remove('active-step');
                            
                            seqMap.activeStep = (seqMap.activeStep + 1) % NUM_STEPS;
                            
                            const nextStepEl = seqMap.gridEl.querySelector(`[data-step="${seqMap.activeStep}"]`);
                            if (nextStepEl) nextStepEl.classList.add('active-step');

                            // IMPORTANT: Since we handled Step Input for one sequencer, we break the loop, 
                            // ensuring only ONE sequencer records per hit when in Step Input Mode.
                            return; 
                        }
                    });

                    if (recorded) {
                        // If a step was recorded via Step Input Mode, we stop here.
                        return; 
                    }

                    // Check for Real-time Recording Mode (Priority 2: Global Real-Time or Manual Sequential)
                    if (isPlaying) {
                        // Real-time recording (Quantized to current step)
                        ['A', 'B', 'C'].forEach(seqId => {
                            const seqMap = SEQUENCER_MAPS[seqId];
                            recordNoteToStep(noteIndex, velocity, currentStep, seqMap.data, seqMap.gridEl);
                        });
                    } else {
                        // Manual sequential recording (Find first empty slot in all sequencers simultaneously if no step is selected)
                        ['A', 'B', 'C'].forEach(seqId => {
                            const seqMap = SEQUENCER_MAPS[seqId];
                            recordManualHit(noteIndex, velocity, seqMap.data, seqMap.gridEl); 
                        });
                    }
                }
            }
        }
        
        function handleNoteInteractionEnd(e) {
            e.preventDefault();
            const el = e.currentTarget.closest('.note-field') || (e.target.classList.contains('note-field') ? e.target : null); 
            if (el) {
                 if (!isTutorialMode) {
                     el.classList.remove('active');
                 }
            }
        }
        
        function getVelocityFromEvent(e) {
             let velocity = 0.7; 
             if (e.type.startsWith('touch') && e.touches.length > 0) {
                 const touch = e.touches[0];
                 if (touch.force !== undefined && touch.force > 0) { 
                     velocity = Math.max(0.1, Math.min(1.0, touch.force));
                 } else {
                     velocity = 0.5 + Math.random() * 0.5; 
                 }
             }
             return velocity;
        }
        
        function getHitData(noteElement, clientX, clientY) {
            const rect = noteElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = rect.width / 2;
            const edgeThreshold = radius * 0.7; 

            const dx = clientX - centerX;
            const dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const isEdgeHit = distance > edgeThreshold; 
            return { isEdgeHit, distance };
        }


        // --- SEQUENCER MODULE (UPDATED for A, B, C) ---

        function initSequencer() {
            // Generate steps for all grids
            ['A', 'B', 'C'].forEach(seqId => {
                for (let i = 0; i < NUM_STEPS; i++) {
                    createStep(i, SEQUENCER_MAPS[seqId].gridEl, seqId);
                }
            });
            
            updateSequencerTiming();

            seqPlayBtn.addEventListener('click', togglePlay);
            seqRecBtn.addEventListener('click', toggleRecord);
            seqClearAllBtn.addEventListener('click', clearAllSequencers);
            bpmInput.addEventListener('change', updateSequencerTiming);
            
            // seqRecBtn.classList.add('active'); // REMOVED: Default Record is OFF
        }
        
        function createStep(index, gridEl, seqId) {
            const step = document.createElement('div');
            step.className = 'seq-step';
            step.dataset.step = index;
            step.dataset.seq = seqId;
            step.title = `Step ${index + 1} (${seqId})`;
            
            step.addEventListener('click', toggleManualStep);
            step.addEventListener('dblclick', clearManualStep); // <--- ADDED DBLCLICK LISTENER
            
            gridEl.appendChild(step);
        }

        // NEW: Function to clear a step on double-click
        function clearManualStep() {
            const step = parseInt(this.dataset.step);
            const seqId = this.dataset.seq;
            const map = SEQUENCER_MAPS[seqId];
            
            // 1. Clear the data from the sequencer map
            map.data[step] = null;
            
            // 2. Remove the visual indicator
            this.classList.remove('note-recorded');
            
            // 3. Ensure step input mode is cleared for this step if it was active
            if (map.activeStep === step) {
                map.activeStep = -1;
                this.classList.remove('active-step');
            }
        }
        
        function updateSequencerTiming() {
            const bpm = parseInt(bpmInput.value) || 120;
            stepIntervalTime = (60000 / bpm) / 4; 
            
            if (isPlaying) {
                stopSequencer();
                startSequencer();
            }
        }
        
        function togglePlay() {
            if (isPlaying) {
                stopSequencer();
            } else {
                if (isTutorialMode) {
                    toggleTutorialMode(); 
                }
                
                if (!currentParams.power) {
                    powerButton.click(); 
                }
                startSequencer();
            }
        }
        
        function toggleRecord() {
            isRecording = !isRecording;
            seqRecBtn.classList.toggle('active', isRecording);
            
            // If Record is turned off, ensure no sequencer is left in Step Input Mode
            if (!isRecording) {
                SEQUENCER_MAPS.A.activeStep = -1;
                SEQUENCER_MAPS.B.activeStep = -1;
                SEQUENCER_MAPS.C.activeStep = -1;
                document.querySelectorAll('.seq-step').forEach(s => s.classList.remove('active-step'));
            }
        }

        function startSequencer() {
            if (isPlaying) return;
            isPlaying = true;
            seqPlayBtn.classList.add('active');
            
            // Clear all active step highlights and step input mode when starting play
            document.querySelectorAll('.seq-step').forEach(step => step.classList.remove('active-step'));
            SEQUENCER_MAPS.A.activeStep = -1;
            SEQUENCER_MAPS.B.activeStep = -1;
            SEQUENCER_MAPS.C.activeStep = -1;
            
            currentStep = -1; 
            
            seqTimer = setInterval(scheduleNextStep, stepIntervalTime);
        }

        function stopSequencer() {
            if (!isPlaying) return;
            isPlaying = false;
            seqPlayBtn.classList.remove('active');
            
            clearInterval(seqTimer);
            
            document.querySelectorAll('.seq-step').forEach(step => step.classList.remove('active-step'));
            currentStep = -1;
        }

        function scheduleNextStep() {
            const previousStep = currentStep;
            
            // 1. Advance Step
            currentStep = (currentStep + 1) % NUM_STEPS;
            
            // 2. Highlight and Play for A, B, C
            ['A', 'B', 'C'].forEach(seqId => {
                const map = SEQUENCER_MAPS[seqId];
                
                // Clear previous step's playback highlight
                if (previousStep !== -1) {
                    const prevStepEl = map.gridEl.querySelector(`[data-step="${previousStep}"]`);
                    if (prevStepEl) prevStepEl.classList.remove('active-step');
                }

                // Highlight current step
                const currentStepEl = map.gridEl.querySelector(`[data-step="${currentStep}"]`);
                if (currentStepEl) {
                    currentStepEl.classList.add('active-step');
                }

                // Play note if data exists
                const noteData = map.data[currentStep];
                if (noteData) {
                    const freqArray = NOTE_FREQUENCIES[noteData.scaleIndex];

                    if (freqArray) {
                        const freq = freqArray[noteData.index];
                        const velocity = noteData.velocity;
                        triggerNote(freq, velocity, false); 
                    } else {
                         console.warn(`Scale index ${noteData.scaleIndex} not found during playback on SEQ ${seqId}.`);
                    }
                }
            });
        }
        
        // UPDATED: Isolates Step Input Mode to only the clicked sequencer
        function toggleManualStep() {
            const step = parseInt(this.dataset.step);
            const seqId = this.dataset.seq;
            const map = SEQUENCER_MAPS[seqId];
            
            if (isPlaying) return; 
            if (!isRecording) return; // Must be in record mode to enter step input

            // 1. Clear ALL active step highlights globally
            document.querySelectorAll('.seq-step').forEach(s => s.classList.remove('active-step'));
            
            // 2. Clear Step Input Mode from ALL sequencers (Isolation logic)
            let deselecting = (map.activeStep === step);
            
            ['A', 'B', 'C'].forEach(id => {
                 SEQUENCER_MAPS[id].activeStep = -1;
            });

            // 3. Set the new Step Input Mode only for the clicked sequencer
            if (deselecting) {
                // Already handled by step 2, but here for clarity:
                map.activeStep = -1;
            } else {
                // Select new step (enters Step Input Mode for this sequencer)
                map.activeStep = step;
                this.classList.add('active-step');
            }
        }

        function recordManualHit(noteIndex, velocity, dataArray, gridEl) {
            let recordStep = dataArray.findIndex(data => data === null);
            
            if (recordStep === -1) {
                recordStep = 0; // Wrap around to the start
            }

            recordNoteToStep(noteIndex, velocity, recordStep, dataArray, gridEl);
        }

        function recordNoteToStep(noteIndex, velocity, step, dataArray, gridEl) {
            if (step === -1 || step === undefined) return; 

            // If the step already has data, clicking a note will overwrite it
            // To clear, the user should manually double-click the recorded step button

            dataArray[step] = { 
                index: noteIndex, 
                velocity: velocity,
                scaleIndex: currentParams.scale 
            };
            
            const stepEl = gridEl.querySelector(`[data-step="${step}"]`);
            if (stepEl) {
                stepEl.classList.add('note-recorded');
            }
        }
        
        function clearAllSequencers() {
            sequencerDataA.fill(null);
            sequencerDataB.fill(null);
            sequencerDataC.fill(null);
            
            SEQUENCER_MAPS.A.activeStep = -1;
            SEQUENCER_MAPS.B.activeStep = -1;
            SEQUENCER_MAPS.C.activeStep = -1;
            
            document.querySelectorAll('.seq-step').forEach(step => {
                step.classList.remove('note-recorded');
                step.classList.remove('active-step'); 
            });
            
            if (isPlaying) {
                stopSequencer();
            }
        }


        // --- TUTORIAL CORE LOGIC (Unchanged) ---
        function toggleTutorialMode() {
            if (isPlaying) {
                stopSequencer(); 
            }
            if (SEQUENCER_MAPS.A.activeStep !== -1 || SEQUENCER_MAPS.B.activeStep !== -1 || SEQUENCER_MAPS.C.activeStep !== -1) {
                 clearAllSequencers(); 
            }

            isTutorialMode = !isTutorialMode;
            tutorialButton.classList.toggle('active', isTutorialMode);
            tutorialList.style.display = isTutorialMode ? 'flex' : 'none';
            tutorialDisplay.style.display = isTutorialMode ? 'flex' : 'none';
            
            if (isTutorialMode) {
                tutorialButton.textContent = "STOP TUTORIAL MODE";
                tutorialDisplay.textContent = "Select a tune above to begin playing!";
                stopLesson();
            } else {
                tutorialButton.textContent = "START TUTORIAL MODE";
                tutorialDisplay.textContent = "Welcome to Free Play!";
                stopLesson(); 
                clearAllNoteHighlights(); 
            }
        }

        function initTutorialInteractions() {
            tutorialButton.addEventListener('click', toggleTutorialMode);
            
            Object.keys(LESSONS).forEach(lessonName => {
                const btn = document.createElement('button');
                btn.className = 'scale-btn tutorial-list-btn';
                btn.textContent = lessonName;
                btn.addEventListener('click', () => startLesson(lessonName));
                tutorialList.appendChild(btn);
            });
        }
        
        function startLesson(lessonName) {
             if (!isAudioInitialized) return;
             if (isPlaying) {
                 stopSequencer(); 
             }
             
            const lessonData = LESSONS[lessonName];
            currentParams.scale = lessonData.scaleIndex;
            
            document.querySelectorAll('.scale-btn:not(.tutorial-list-btn)').forEach(b => b.classList.remove('active'));
            
            const scaleBtnToActivate = document.querySelector(`.scale-btn[data-scale-index="${lessonData.scaleIndex}"]`);
            if (scaleBtnToActivate) {
                 scaleBtnToActivate.classList.add('active');
            }
            
            const names = getScaleNames(lessonData.scaleIndex);
            generateHandpanNotes(NOTE_FREQUENCIES[lessonData.scaleIndex], names);

            currentLesson = lessonData.sequence;
            currentStepIndex = 0;
            
            tutorialDisplay.style.borderLeftColor = 'var(--accent-yellow)';
            
            if (!currentParams.power) {
                 powerButton.click(); 
            }
            
            tutorialDisplay.textContent = `Lesson: ${lessonName} - Get Ready...`;
            clearAllNoteHighlights();
            stepDelayTimeout = setTimeout(advanceLessonStep, 1000);
        }

        function stopLesson() {
            if (stepDelayTimeout) {
                clearTimeout(stepDelayTimeout);
                stepDelayTimeout = null;
            }
            currentLesson = null;
            currentStepIndex = 0;
            isWaitingForHit = false;
            clearAllNoteHighlights();
            tutorialDisplay.style.borderLeftColor = 'var(--accent-yellow)';
        }

        function advanceLessonStep() {
            clearAllNoteHighlights();

            if (currentStepIndex >= currentLesson.length) {
                tutorialDisplay.style.borderLeftColor = 'var(--accent-green)';
                tutorialDisplay.textContent = " Lesson Complete! Great job! ";
                isWaitingForHit = false;
                return;
            }

            const expectedIndex = currentLesson[currentStepIndex];
            const noteElement = document.querySelector(`.note-field[data-note-index="${expectedIndex}"]`);
            const noteName = noteElement ? noteElement.textContent : 'Note';

            if (noteElement) {
                noteElement.classList.add('tutorial-active');
                tutorialDisplay.style.borderLeftColor = 'var(--accent-yellow)';
                tutorialDisplay.textContent = `STEP ${currentStepIndex + 1}: Hit the ${noteName} now!`;
                isWaitingForHit = true;
            } else {
                console.error("Tutorial error: Note element not found for index", expectedIndex);
            }
        }
        
        function checkTutorialHit(hitElement, velocity, isEdgeHit) {
            if (!isWaitingForHit) {
                return;
            }
            
            const hitIndex = parseInt(hitElement.dataset.noteIndex);
            const expectedIndex = currentLesson[currentStepIndex];

            if (hitIndex === expectedIndex) {
                isWaitingForHit = false;
                
                triggerNote(parseFloat(hitElement.dataset.freq), velocity, isEdgeHit);
                
                hitElement.classList.remove('tutorial-active', 'tutorial-error');
                hitElement.classList.add('tutorial-success');
                tutorialDisplay.style.borderLeftColor = 'var(--accent-green)';
                tutorialDisplay.textContent = " Correct! Moving to the next note...";

                currentStepIndex++;
                
                stepDelayTimeout = setTimeout(advanceLessonStep, 800);
                
            } else {
                hitElement.classList.remove('tutorial-active', 'tutorial-error');
                hitElement.classList.add('tutorial-error');
                tutorialDisplay.style.borderLeftColor = 'var(--accent-red)';
                
                const expectedNoteName = document.querySelector(`.note-field[data-note-index="${expectedIndex}"]`)?.textContent || 'highlighted note';
                tutorialDisplay.textContent = ` That was the wrong note. Try hitting the ${expectedNoteName}!`;
                
                clearVisualFeedback(hitElement, 400); 
            }
        }
        
        function clearVisualFeedback(element, delay = 0) {
            if (delay > 0) {
                 setTimeout(() => element.classList.remove('tutorial-error', 'tutorial-success'), delay);
            } else {
                 element.classList.remove('tutorial-error', 'tutorial-success');
            }
        }

        function clearAllNoteHighlights() {
            document.querySelectorAll('.note-field').forEach(el => {
                if (el && el.classList) {
                    el.classList.remove('active', 'tutorial-active', 'tutorial-success', 'tutorial-error');
                }
            });
        }


        // --- CONTROL INTERACTIONS (Unchanged) ---
        function initSliderInteractions() {
            Object.keys(sliders).forEach(key => {
                const slider = sliders[key];
                const display = sliderVals[key];

                slider.addEventListener('input', (e) => {
                    const newVal = parseFloat(e.target.value);
                    currentParams[key] = newVal; 
                    display.textContent = newVal.toFixed(2);
                    
                    if (isAudioInitialized) {
                        updateMasterGains();
                    }
                });
            });
        }
        
        function getScaleNames(scaleIndex) {
            if (scaleIndex === 6) {
                return NOTE_NAMES_CHAKRA;
            }
            return NOTE_NAMES_D_MINOR;
        }

        function initScaleButtonInteractions() {
            document.querySelectorAll('.scale-btn:not(.tutorial-list-btn)').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (isTutorialMode) {
                        tutorialDisplay.style.borderLeftColor = 'var(--accent-red)';
                        tutorialDisplay.textContent = " Stop the tutorial before changing scales!";
                        clearVisualFeedback(tutorialDisplay, 2000);
                        return;
                    }
                    
                    if (isPlaying) stopSequencer();
                    
                    // Clear all step input selections
                    SEQUENCER_MAPS.A.activeStep = -1;
                    SEQUENCER_MAPS.B.activeStep = -1;
                    SEQUENCER_MAPS.C.activeStep = -1;
                    document.querySelectorAll('.seq-step').forEach(s => s.classList.remove('active-step'));

                    const newScaleIndex = parseInt(e.target.dataset.scaleIndex);
                    if (newScaleIndex === currentParams.scale) return; 

                    document.querySelectorAll('.scale-btn:not(.tutorial-list-btn)').forEach(b => b.classList.remove('active'));
                    
                    document.querySelector(`.scale-btn[data-scale-index="${newScaleIndex}"]`).classList.add('active');

                    currentParams.scale = newScaleIndex;
                    const names = getScaleNames(newScaleIndex);
                    generateHandpanNotes(NOTE_FREQUENCIES[newScaleIndex], names);
                });
            });
        }
        
        function initUtilityButtonInteractions() {
            surfaceButton.addEventListener('click', () => {
                currentParams.surfaceSound = !currentParams.surfaceSound;
                surfaceButton.classList.toggle('active', currentParams.surfaceSound);
            });

            document.getElementById('bluetooth-btn').addEventListener('click', (e) => {
                e.currentTarget.classList.toggle('active');
            });
        }

        function resetUIAndParams() {
            currentParams = { ...DEFAULT_PARAMS };
            currentParams.power = true; 
            
            Object.keys(sliders).forEach(key => {
                sliders[key].value = DEFAULT_PARAMS[key];
                sliderVals[key].textContent = DEFAULT_PARAMS[key].toFixed(2);
            });
            
            const defaultScaleBtn = document.querySelector(`.scale-btn[data-scale-index="${DEFAULT_PARAMS.scale}"]`);
            if (defaultScaleBtn) {
                defaultScaleBtn.classList.add('active');
            }
            
            powerButton.classList.add('active');
            surfaceButton.classList.add('active');
            
            if (isAudioInitialized) {
                audioCtx.resume();
                updateMasterGains(); 
            }
        }
        
        powerButton.addEventListener('click', async () => {
            if (!isAudioInitialized) return;

            if (currentParams.power) {
                // Turning OFF
                currentParams.power = false;
                powerButton.classList.remove('active');
                
                if (isPlaying) stopSequencer();
                if (isTutorialMode) {
                    toggleTutorialMode(); 
                    clearAllNoteHighlights(); 
                }
                
                // Clear audio path gently
                masterGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.1); 
                dimensionFeedback.gain.setValueAtTime(0, audioCtx.currentTime); 
                
                setTimeout(async () => {
                    if (audioCtx.state !== 'suspended') {
                        await audioCtx.suspend(); 
                    }
                }, 150); 
                
            } else {
                // Turning ON
                currentParams.power = true;
                powerButton.classList.add('active');
                
                if (audioCtx.state !== 'running') {
                    await audioCtx.resume();
                }
                masterGain.gain.setTargetAtTime(currentParams.volume, audioCtx.currentTime, 0.1); 
                updateMasterGains();
            }
        });

        window.addEventListener('resize', () => {
            if (isAudioInitialized) {
                const names = getScaleNames(currentParams.scale);
                generateHandpanNotes(NOTE_FREQUENCIES[currentParams.scale], names);
            }
        });
    </script>
</body>
</html>
